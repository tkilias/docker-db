#! /usr/bin/env python2.7

import sys, os, argparse, pprint, subprocess, time, tarfile, io, docker
from libexadt import exadt_conf, docker_handler, device_handler, docker_rpc_handler, EXAConf, utils
import shutil
from libexadt.EXAConf import config

# Flush STDOUT continuously
sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)

my_version = "6.0.11"
info_arc_prefix = "exasol_docker_info"
confirm_yes = False

#{{{ static variables for the "self contained image"
sc_root = "/exa"
sc_etc = "/exa/etc"
sc_owner = 500
sc_group = 500
sc_cluster_name = "cl4"
sc_image = "exasol/docker-db:latest" #not relevant
sc_device_type = "file"
sc_license = "/.license.xml"
cos_auth_socket = "/var/run/ecos_unix_auth"
#}}}

#{{{ log_err
def log_err(msg):
    sys.stderr.write('[%s] %s\n' % (time.strftime('%Y-%m-%d %H:%M:%S'), msg))
#}}}

#{{{ Get script path
def get_script_path():
    """
    Returns the absolute path of the exadt script that is currently executed.
    """
    script = os.path.realpath(__file__)
    # __file__ may point to the .pyc file
    if script.endswith(".pyc"):
        script = script[:-1]
    return script
#}}}

#{{{ Confirm
def confirm(msg):
    """
    Asks the user for confirmation.
    """
    if confirm_yes:
        return True

    choice = ""
    while choice not in set(['y','Y','n','N']):
        choice = raw_input("%s (y/n): " % msg).lower()
    return choice == 'y'
#}}}

#{{{ Cluster started
def cluster_started(root):
    """
    Checks if the cluster with the given root has been started
    (i. e. there are containers of this cluster).
    """
    try:
        exaconf = EXAConf.EXAConf(root, False)
    except EXAConf.EXAConfError as e:
        print e
        # return False (necessary e. g. if the root-directory has already been deleted)
        return False
    # EXAConf may be un-inititalized if delete-cluster is
    # called directly after create-cluster
    if not exaconf.initialized():
        return False
    try:
        # validate manually if initialized (see above)
        exaconf.validate()
        dh = docker_handler.docker_handler()
        dh.set_exaconf(exaconf)
        res = dh.cluster_started()
    except docker_handler.DockerError as e:
        print e
        sys.exit(1)
    return res
#}}}

# {{{ Create cluster
def create_cluster(cmd):
    conf = exadt_conf.exadt_conf()
    # always us absolute path
    root = os.path.abspath(cmd.root)
    root = os.path.normpath(root)
    # create root-directory if requested
    if cmd.create_root:
        try: 
            os.makedirs(root)
        except OSError:
            if not os.path.isdir(root):
                print "Failed to create root-directory '%s'!" % root
                raise
    elif not os.path.isdir(root):
        print "Root directory '%s' does not exist (or is a file)!" % root
        sys.exit(1)
    # create entry in config
    try:
        conf.create_cluster(cmd.cluster, root)
    except exadt_conf.ConfError as e:
        print e
        sys.exit(1)
#}}}    

# {{{ Delete cluster
def delete_cluster(cmd):
    try:
        conf = exadt_conf.exadt_conf()
        root = conf.get_root(cmd.cluster)
    except exadt_conf.ConfError as e:
        print e
        sys.exit(1)
    # check if has been started (i. e. containers exist)
    if cluster_started(root):
        print "Cluster '%s' has existing containers. It has to be stopped before it can be deleted!" % cmd.cluster
        sys.exit(1)
    # ask for confirmation
    msg = "Do you really want to delete cluster '%s'%s? " % \
            (cmd.cluster, " (and all file-devices)" if not (cmd.keep_root or cmd.keep_mapped_devices) else "")
    if not confirm(msg):
        print "Aborted."
        sys.exit(1)

    # check if cluster has been initialized (may be un-initialized 
    # if delete-cluster is called directly after create-cluster)
    initialized = False
    try:
        exaconf = EXAConf.EXAConf(root, False)
        initialized = exaconf.initialized()
    except EXAConf.EXAConfError as e:
        print e
        # interpret exception as "not initialized" and proceed

    # delete root-dir if not prevented
    # NOTE  : this is done by starting new containers and executing 'rm -rf /exa' because 
    #         some of the files belong to root (due to the privileged mode) and can't  
    #         be deleted if exadt has been called by a normal user.
    if initialized and not cmd.keep_root:
        print "Deleting root directory '%s'." % root
        try:
            dh = docker_handler.docker_handler(quiet=True)
            dh.set_exaconf(exaconf)
            dh.start_cluster(cmd = "rm -rf /exa", auto_remove=True, dummy_mode=True)
        except docker_handler.DockerError as e:
            print "Errors occured while trying to delete the root directory: %s" % e
        # delete the root-directory itself and the node directories
        shutil.rmtree(root, True)
    # un-initialized clusters have to be deleted without accessing EXAConf
    elif not cmd.keep_root:
        shutil.rmtree(root, True)

    # check if deletion was successfull (may fail if there are root-only files in an unitialized cluster)
    if os.path.isdir(root):
        print "WARNING: root directory '%s' could not be completely deleted! Please delete it manually before reusing it." % root
 
    # delete mapped devices if not prevented
    # --> we delete the complete '$name' directories (they are created automatically)
    # NOTE : we do this AFTER deleting the root directory, otherwise the docker-handler would
    #        fail to mount the volumes specified in EXAConf (when executing the deletion command)
    if initialized and not cmd.keep_mapped_devices:
        try:
            # validate manually if initalized
            exaconf.validate()
            nodes_conf = exaconf.get_nodes_conf()
        except EXAConf.EXAConfError as e:
            print e
        for node in nodes_conf.itervalues():
            for disk in node.disks.itervalues():
                if disk.has_key("mapping"):
                    for dev,path in disk.mapping:
                        try:
                            # follow symlink
                            path = os.path.realpath(path)
                            # path can also be a file within '$name/'!
                            if os.path.isfile(path):
                                path = os.path.dirname(path)
                            print "Deleting directory '%s'." % path
                            shutil.rmtree(path, True)
                        except OSError as e:
                            print "Failed to delete '%s': %s." % (path, e)

    # delete entry from config
    conf.delete_cluster(cmd.cluster)
#}}}    

#{{{ Extract versions
def extract_versions(cmd=None, env=None, image=None):
    """
    Extracts DB, OS and image version from either:
    - the given command, 
    - the given environment or
    - the given docker image
    and returns the first occurence of each version number.
    """
    db_version = None
    os_version = None
    img_version = None
    # 1. use versions given in the command
    if cmd:
        if cmd.db_version and cmd.db_version.strip() != "":
            db_version = cmd.db_version.strip()
        if cmd.os_version and cmd.os_version.strip() != "":
            os_version = cmd.os_version.strip()
        if cmd.img_version and cmd.img_version.strip() != "":
            img_version = cmd.img_version.strip()
    # 2. extract versions from environment
    if env:
        if not db_version and "EXA_DB_VERSION" in env:
            db_version = env["EXA_DB_VERSION"]
        if not os_version and "EXA_OS_VERSION" in env:
            os_version = env["EXA_OS_VERSION"] 
        if not img_version and "EXA_IMG_VERSION" in env:
            img_version = env["EXA_IMG_VERSION"]
    # 3. extract versions from docker image 
    if image:
        if not db_version or not os_version or not img_version:
            try:
                dh = docker_handler.docker_handler()
                ic = dh.get_image_conf(image)
            except docker_handler.DockerError as e:
                print e
                sys.exit(1)
            if not db_version:
                db_version = ic.labels.dbversion
            if not os_version:
                os_version = ic.labels.osversion 
            if not img_version:
                img_version = ic.labels.version
    return (db_version, os_version, img_version)
#}}}

#{{{ Get versioned image name
def get_versioned_image_name(image):
    """
    Replaces 'latest' in the given image name with the actual version.
    """
    image = image.strip()
    if image.split(":")[1] == "latest":
        try:
            dh = docker_handler.docker_handler()
            ic = dh.get_image_conf(image)
        except docker_handler.DockerError as e:
            print e
            sys.exit(1)
            image = image.split(":")[0] + ":" + ic.labels.version
    return image
#}}}

# {{{ Init cluster
def init_cluster(cmd):
    try:
        conf = exadt_conf.exadt_conf()
        root = conf.get_root(cmd.cluster)
    except exadt_conf.ConfError as e:
        print e
        sys.exit(1)
    # check if root and license actually exist
    if not os.path.isdir(root):
        print "Root directory '%s' does not exist (or is a file)!" % root
        sys.exit(1)
    if not os.path.isfile(cmd.license):
        print "License '%s' does not exist (or is a directory)!" % os.path.abspath(cmd.license)
        sys.exit(1)
    # check params
    if cmd.device_type and cmd.device_type not in ['block','file']:
        print "Device-type must be 'block' or 'file'!" 
        sys.exit(1)
    if cmd.auto_storage and cmd.device_type != 'file':
        print "'--auto-storage' is only supported for device-type 'file'!"
        sys.exit(1)
    # check if has been started (i. e. containers exist)
    if cluster_started(root):
        print "Cluster '%s' has existing containers. It has to be stopped before it can be re-initialized!" % cmd.cluster
        sys.exit(1)
    # extract versions
    db_version, os_version, img_version = extract_versions(cmd=cmd,
                                                           image=cmd.image)
    # check and re-init root if requested
    files = os.listdir(root)
    if files:
        if cmd.force:
            for e in files:
                name = os.path.join(root, e)
                if os.path.isdir(name):
                    shutil.rmtree(name, True)
                else:
                    os.unlink(name)
        else:
            print "Root directory '%s' is not empty! Use --force to force re-initialization." % root
            sys.exit(1)
    # create EXAConf
    try:
        exaconf = EXAConf.EXAConf(root, False)
    except EXAConf.EXAConfError as e:
        print e
        sys.exit(1)
    # create directory structure
    for node in range(1, cmd.num_nodes+1):
        node_root = os.path.join(root, exaconf.node_root_prefix + str(exaconf.max_reserved_node_id + node))
        create_node_dirs(node_root, exaconf)
    # initialize EXAConf
    exaconf.initialize(cmd.cluster, cmd.image, 
                       cmd.num_nodes, cmd.device_type, cmd.force, "Docker",
                       db_version = db_version,
                       os_version = os_version,
                       img_version = img_version,
                       license = cmd.license)
    # create devices and volumes if requested
    if cmd.auto_storage:
        try:
            devh = device_handler.device_handler(exaconf)
            devh.auto_create_file_devices()
        except device_handler.DeviceError as e:
            print e
            sys.exit(1)

    print "Successfully initialized root directory '%s'." % root
#}}}

#{{{ Init sc
def init_sc(cmd):
    """
    Called from within a 'standalone-container': creates the container filesystem,
    storage devices and EXAConf. Finally calls exainit, which continues the startup
    process.
    """
    
    do_full_init = False
    db_version, os_version, img_version = extract_versions(cmd=cmd,
                                                           env=os.environ)

    # 1. Create /exa/etc if it does not exist
    # --> needed in order to create an exaconf instance
    if not os.path.exists(sc_etc):
        log_err("exadt:: '%s' does not exist! Doing full initialization." % sc_etc)
        do_full_init = True
        os.makedirs(sc_etc)
    else:
        log_err("exadt:: '%s' already exists! Doing partial initialization." % sc_etc)

    # 2. Determine the local IP adress
    log_err("exadt:: searching for the first interface with state UP")
    first_if = utils.get_first_interface(timeout=15)
    local_ifs = utils.get_all_interfaces(timeout=15, up_only=True)

    # 3. Create EXAConf (may be uninitialized)
    try:
        exaconf = EXAConf.EXAConf(sc_etc, False)
    except EXAConf.EXAConfError as e:
        log_err(e)
        sys.exit(1)  
 
    # 4. check compatibility before doing anything else
    # --> the persistent volume may need to be updated
    if exaconf.initialized():
        (c, res) = exaconf.check_update_needed(db_version=db_version, 
                                               os_version=os_version, 
                                               img_version = img_version)
        if c == True:
            print "The given docker volume is not compatible with this docker image because of the following version mismatch(es):\n%sPlease update the volume (using 'update-sc')!" % (res)
            sys.exit(1)
 
    # 5. Create all other directories if they don't exist
    create_node_dirs(sc_root, exaconf)

    # 6. copy license to the correct destination
    log_err("exadt:: copying license file '%s' to '%s'" % (sc_license, sc_etc))
    shutil.copy(sc_license, os.path.join(sc_etc, "license.xml"))

    # 7. Init EXAConf
    #    NOTE : the version numbers are taken from the environment, 
    #           the image name is not relevant and the license has already
    #           been copied to the right place.
    if not exaconf.initialized():
        log_err("exadt:: initializing EXAConf")
        exaconf.initialize(sc_cluster_name, sc_image, 
                           cmd.num_nodes, sc_device_type, 
                           False, "Docker",
                           license = "/exa/etc/license.xml",
                           db_version = db_version,
                           os_version = os_version,
                           img_version = img_version,
                           add_archive_volume=False,
                           quiet=True,
                           template_mode=cmd.template)
        # Set local IP in EXAConf
        # --> skip in 'template' mode (will probably be replaced anyway)
        if not cmd.template:
            try:
                exaconf.set_node_network(cmd.node_id, private=first_if[1])
            except EXAConf.EXAConfError as e:
                log_err(e)
                sys.exit(1)
            log_err("exadt:: using interface '%s' with address '%s'." % (first_if[0], first_if[1]))
    # if EXAConf is already initialized, we compare the current local IP
    # with the one in the EXAConf, instead of setting it
    elif not cmd.template:
        nodes_conf = exaconf.get_nodes_conf()
        if cmd.node_id in nodes_conf.iterkeys():
            priv_net = nodes_conf[cmd.node_id].private_net
            priv_net_up = False
            # search for the current network within the list of UP interfaces
            for up_if in local_ifs:
                if priv_net == up_if[1]:
                    priv_net_up = True
                    break
            if not priv_net_up:
                log_err("exadt::ERROR: the private interface with address '%s' either does not exist or is down." 
                        % (priv_net))
                sys.exit(1)
        else:
            log_err("exadt::ERROR: can't find node ID '%s' in EXAConf." % cmd.node_id)
            sys.exit(1)
      
    # 8. create storage devices
    # --> skip in 'template' mode
    if do_full_init and not cmd.template:
        log_err("exadt:: creating EXAStorage devices")
        try:
            devh = device_handler.device_handler(exaconf)
            devh.auto_create_file_devices(container_internal=True)
        except device_handler.DeviceError as e:
            log_err(e)
            sys.exit(1)

    # 9. change DB, volume and service owner
    log_err("exadt:: changing DB, volume and BucketFS owner to %i : %i" % (sc_owner, sc_group))
    try:
        conf = config()
        conf.owner = (sc_owner, sc_group)
        exaconf.set_storage_volume_conf(conf, "all")
        exaconf.set_database_conf(conf, "all")
        bfs_conf = config()
        bfs_conf.service_owner = (sc_owner, sc_group)
        exaconf.set_bucketfs_conf(bfs_conf)
    except EXAConf.EXAConfError as e:
        log_err(e)
        sys.exit(1)
 
    # 10. change owner and group of all files and directories below "/exa"
    for root, dirs, files in os.walk(sc_root):
        os.lchown(root, sc_owner, sc_group)
        for d in dirs:
            os.lchown(os.path.join(root, d), sc_owner, sc_group)
        for f in files:
            os.lchown(os.path.join(root, f), sc_owner, sc_group)

    # 11. set and export hostname
    hostname = "n" + str(cmd.node_id)
    log_err("exadt:: setting hostname to '%s'" % hostname)
    os.environ['EXA_NODE_ID'] = str(cmd.node_id)
    os.environ['HOSTNAME'] = hostname
    subprocess.call(['/bin/hostname', hostname])

    # 12. remove authentication socket if it exists
    if os.path.exists(cos_auth_socket):
        log_err("exadt:: removing '%s'" % cos_auth_socket)
        os.remove(cos_auth_socket)        

    # 13. call exainit
    # --> or exit if requested
    if cmd.template:
        log_err("exadt:: template mode: printing EXAConf and exiting:\n")
        exaconf.config.write(outfile=sys.stdout)
        sys.exit(0)
    else:
        exainit_cmd = '/usr/opt/EXASuite-6/EXAClusterOS-6.0.11/libexec/exainit.py'
        log_err("exadt:: calling '%s'" % exainit_cmd)
        os.execl(exainit_cmd, exainit_cmd)
#}}}

#{{{ Create node dirs
def create_node_dirs(node_root, exaconf):
    """
    Creates all default directories in the given node root directory.
    """
    if not os.path.exists(node_root):
        os.makedirs(node_root)
    if not os.path.exists(os.path.join(node_root, exaconf.etc_dir)):
        os.makedirs(os.path.join(node_root, exaconf.etc_dir))
    if not os.path.exists(os.path.join(node_root, exaconf.tmp_dir)):
        os.makedirs(os.path.join(node_root, exaconf.tmp_dir))
    if not os.path.exists(os.path.join(node_root, exaconf.spool_dir)):
        os.makedirs(os.path.join(node_root, exaconf.spool_dir))
    if not os.path.exists(os.path.join(node_root, exaconf.sync_dir)):
        os.makedirs(os.path.join(node_root, exaconf.sync_dir))
    if not os.path.exists(os.path.join(node_root, exaconf.job_dir)):
        os.makedirs(os.path.join(node_root, exaconf.job_dir))
    if not os.path.exists(os.path.join(node_root, exaconf.job_queue_dir)):
        os.makedirs(os.path.join(node_root, exaconf.job_queue_dir))
    if not os.path.exists(os.path.join(node_root, exaconf.job_run_dir)):
        os.makedirs(os.path.join(node_root, exaconf.job_run_dir))
    if not os.path.exists(os.path.join(node_root, exaconf.job_finish_dir)):
        os.makedirs(os.path.join(node_root, exaconf.job_finish_dir))
    if not os.path.exists(os.path.join(node_root, exaconf.job_archive_dir)):
        os.makedirs(os.path.join(node_root, exaconf.job_archive_dir))
    if not os.path.exists(os.path.join(node_root, exaconf.ssl_dir)):
        os.makedirs(os.path.join(node_root, exaconf.ssl_dir))
    if not os.path.exists(os.path.join(node_root, exaconf.md_dir)):
        os.makedirs(os.path.join(node_root, exaconf.md_dir))
    if not os.path.exists(os.path.join(node_root, exaconf.md_storage_dir)):
        os.makedirs(os.path.join(node_root, exaconf.md_storage_dir))
    if not os.path.exists(os.path.join(node_root, exaconf.md_dwad_dir)):
        os.makedirs(os.path.join(node_root, exaconf.md_dwad_dir))
    if not os.path.exists(os.path.join(node_root, exaconf.log_dir)):
        os.makedirs(os.path.join(node_root, exaconf.log_dir))
    if not os.path.exists(os.path.join(node_root, exaconf.logd_dir)):
        os.makedirs(os.path.join(node_root, exaconf.logd_dir))
    if not os.path.exists(os.path.join(node_root, exaconf.cored_log_dir)):
        os.makedirs(os.path.join(node_root, exaconf.cored_log_dir))
    if not os.path.exists(os.path.join(node_root, exaconf.db_log_dir)):
        os.makedirs(os.path.join(node_root, exaconf.db_log_dir))
    if not os.path.exists(os.path.join(node_root, exaconf.data_dir)):
        os.makedirs(os.path.join(node_root, exaconf.data_dir))
    if not os.path.exists(os.path.join(node_root, exaconf.bucketfs_dir)):
        os.makedirs(os.path.join(node_root, exaconf.bucketfs_dir))
    if not os.path.exists(os.path.join(node_root, exaconf.storage_dir)):
        os.makedirs(os.path.join(node_root, exaconf.storage_dir))
    if not os.path.exists(os.path.join(node_root, exaconf.bucketfs_dir, exaconf.def_bucketfs)):
        os.makedirs(os.path.join(node_root, exaconf.bucketfs_dir, exaconf.def_bucketfs))   
    if not os.path.exists(os.path.join(node_root, exaconf.docker_log_dir)):
        os.makedirs(os.path.join(node_root, exaconf.docker_log_dir))
#}}}

#{{{ List clusters
def list_clusters(cmd):
    conf = exadt_conf.exadt_conf()
    clusters = conf.get_clusters()
    if len(clusters) == 0:
        print "No clusters found in %s." % conf.get_conf_paths()
        sys.exit(0)

    # build dict containg all information
    width = [len("CLUSTER"), len("ROOT"), len("IMAGE NAME"), len("IMAGE VERSION"), len("DB VERSION"), len("OS VERSION")]
    clusters_info = config()
    for cluster,root in clusters.items():
        ci = config({"root" : os.path.normpath(root),
                     "image" : "<uninitialized>",
                     "version" : "<unknown>",
                     "db_version" : "<unknown>",
                     "os_version" : "<unknown>"})
        #cluster may be uninitialized
        try:
            exaconf = EXAConf.EXAConf(root, True)
            ci.image = exaconf.get_docker_image()
        except EXAConf.EXAConfError:
            pass
        #query image info if it's initialized
        if ci.image != "<uninitialized>":
            try:
                dh = docker_handler.docker_handler()
                ic = dh.get_image_conf(ci.image)
                ci.version = ic.labels.version
                ci.db_version = ic.labels.dbversion
                ci.os_version = ic.labels.osversion
            except docker_handler.DockerError as e:
                print e
        clusters_info[cluster] = ci
        # update column widths
        width[0] = max(width[0], len(cluster))
        width[1] = max(width[1], len(ci.root))
        width[2] = max(width[2], len(ci.image))
        width[3] = max(width[3], len(ci.version))
        width[4] = max(width[4], len(ci.db_version))
        width[5] = max(width[5], len(ci.os_version))
                
    print " %- *s   %- *s   %- *s   %- *s   %- *s   %- *s" % (width[0], "CLUSTER", 
                                                              width[1], "ROOT", 
                                                              width[2], "IMAGE NAME", 
                                                              width[3], "IMAGE VERSION", 
                                                              width[4], "DB VERSION", 
                                                              width[5], "OS VERSION")
    for cluster,ci in clusters_info.iteritems():
        print " %- *s   %- *s   %- *s   %- *s   %- *s   %- *s" % (width[0], cluster,
                                                                  width[1], ci.root,
                                                                  width[2], ci.image,
                                                                  width[3], ci.version,
                                                                  width[4], ci.db_version,
                                                                  width[5], ci.os_version)
#}}}

#{{{ Docker version
def docker_version(cmd):
    try:
        dh = docker_handler.docker_handler(verbose=True)
        print "====== Docker Version ======"
        pp = pprint.PrettyPrinter()
        pp.pprint(dh.version())
        print "====== Docker-py Version ======"
        print docker.version
    except docker_handler.DockerError as e:
        print e
        sys.exit(1)
#}}}

#{{{ Start cluster
def start_cluster(cmd):
    try:
        conf = exadt_conf.exadt_conf()
        root = conf.get_root(cmd.cluster)
    except exadt_conf.ConfError as e:
        print e
        sys.exit(1)
    try:
        exaconf = EXAConf.EXAConf(root, True)
        # Check for compatibility between the current EXAConf and the image
        # (only done before starting a cluster because all other operations
        # still have to work, especially the update)
        (c, ev, iv) = exaconf.check_img_compat()
        if c == False:
            print "EXAConf version (%s) is not compatible with image version (%s). Please update your installation!" % (ev, iv)
            sys.exit(1)
        # check if the volumes all have disks assigned
        for name,vol in exaconf.get_storage_volumes().iteritems():
            if vol.disk is None:
                print "Volume '%s' has no disk! Aborting cluster startup." % name
                sys.exit(1)
    except EXAConf.EXAConfError as e:
        print e
        sys.exit(1)
    # call docker handler
    try:
        dh = docker_handler.docker_handler(verbose=cmd.verbose)
        dh.set_exaconf(exaconf)
        dh.start_cluster(cmd = cmd.command)
    except docker_handler.DockerError as e:
        print e
        sys.exit(1)
#}}}

#{{{ Stop cluster
def stop_cluster(cmd):
    try:
        conf = exadt_conf.exadt_conf()
        root = conf.get_root(cmd.cluster)
    except exadt_conf.ConfError as e:
        print e
        sys.exit(1)
    try:
        exaconf = EXAConf.EXAConf(root, True)
    except EXAConf.EXAConfError as e:
        print e
        sys.exit(1)
    try:
        dh = docker_handler.docker_handler(verbose=cmd.verbose)
        dh.set_exaconf(exaconf)
        if dh.cluster_online():
            drh = docker_rpc_handler.docker_rpc_handler(exaconf, quiet=True)
            print "Stopping database(s)...",
            drh.stop_database()
            print "successful"
        dh.stop_cluster(cmd.timeout)
    except docker_handler.DockerError as e:
        print e
        sys.exit(1)
#}}}

#{{{ Update cluster
def update_cluster(cmd):
    try:
        conf = exadt_conf.exadt_conf()
        root = conf.get_root(cmd.cluster)
    except exadt_conf.ConfError as e:
        print e
        sys.exit(1)
    # check if has been started (i. e. containers exist)
    if cluster_started(root):
        print "Cluster '%s' has existing containers. It has to be stopped before it can be updated!" % cmd.cluster
        sys.exit(1)
    # extract new versions
    new_db_version, new_os_version, new_img_version = extract_versions(cmd=cmd,
                                                                       image=cmd.image)
    # update image and versions        
    try:
        exaconf = EXAConf.EXAConf(root, True)
        old_docker_image = exaconf.get_docker_image()
        old_db_version = exaconf.get_db_version()
        old_os_version = exaconf.get_os_version()
        old_img_version = exaconf.get_img_version()
        exaconf.update_docker_image(cmd.image)
        exaconf.update_db_version(new_db_version)
        exaconf.update_os_version(new_os_version)
        exaconf.update_img_version(new_img_version)
        nodes_conf = exaconf.get_nodes_conf()
    except EXAConf.EXAConfError as e:
        print e
        sys.exit(1)
    # create missing directories
    for node_conf in nodes_conf.itervalues():
        create_node_dirs(node_conf.docker_volume, exaconf)
    # print update info
    col_width = len(old_docker_image)
    print "Cluster '%s' has been successfully updated!" % cmd.cluster
    print "- Image name :  %-*s --> %s" % (col_width, old_docker_image, exaconf.get_docker_image())
    print "- Image ver. :  %-*s --> %s" % (col_width, old_img_version, exaconf.get_img_version())
    print "- DB ver.    :  %-*s --> %s" % (col_width, old_db_version, exaconf.get_db_version())
    print "- OS ver.    :  %-*s --> %s" % (col_width, old_os_version, exaconf.get_os_version())
    print "Restart the cluster in order to apply the changes." 
#}}}

#{{{ Update sc
def update_sc(cmd):
    """
    Update a 'standalone-container' (called from within the running container)
    NOTE : the image name is not modified because it is ignored anyway for standalone-containers.
    """
    new_db_version, new_os_version, new_img_version = extract_versions(cmd=cmd, 
                                                                       env=os.environ)
    # update image and versions        
    try:
        exaconf = EXAConf.EXAConf(sc_etc, True)
        old_db_version = exaconf.get_db_version()
        old_os_version = exaconf.get_os_version()
        old_img_version = exaconf.get_img_version()
        exaconf.update_db_version(new_db_version)
        exaconf.update_os_version(new_os_version)
        exaconf.update_img_version(new_img_version)
    except EXAConf.EXAConfError as e:
        print e
        sys.exit(1) 
    col_width = len(old_img_version)
    print "Container has been successfully updated!"
    print "- Image ver. :  %-*s --> %s" % (col_width, old_img_version, exaconf.get_img_version())
    print "- DB ver.    :  %-*s --> %s" % (col_width, old_db_version, exaconf.get_db_version())
    print "- OS ver.    :  %-*s --> %s" % (col_width, old_os_version, exaconf.get_os_version())
#}}}

#{{{ ps
def ps(cmd):
    try:
        conf = exadt_conf.exadt_conf()
        root = conf.get_root(cmd.cluster)
    except exadt_conf.ConfError as e:
        print e
        sys.exit(1)
    try:
        exaconf = EXAConf.EXAConf(root, True)
    except EXAConf.EXAConfError as e:
        print e
        sys.exit(1)
    try:
        dh = docker_handler.docker_handler()
        dh.set_exaconf(exaconf)
        containers = dh.get_containers()
    except docker_handler.DockerError as e:
        print e
        sys.exit(1)
    # not running?
    if len(containers) == 0:
        print "No containers found for cluster '%s'." % cmd.cluster
        sys.exit(0)
    # verbose output    
    if cmd.verbose:
        pprint.pprint(containers)
    # create list containing the column widths (use max. len of each column entry)
    width = [0] * 7
    width[0] = max(max(len(c['Labels']['NodeID']) for c in containers), len("NODE_ID"))
    width[1] = max(max(len(c['Status']) for c in containers), len("STATUS"))
    width[2] = max(max(len(c['Labels']['version']) for c in containers), len("IMAGE VERSION"))
    width[3] = max(max(len(c['Labels']['Name']) for c in containers), len("NAME"))
    width[4] = 12
    width[5] = max(max(len(c['Names'][0].lstrip("/")) for c in containers), len("CONTAINER NAME"))
    width[6] = 0
    for c in containers:
        ports = [ (d["PublicPort"], d["PrivatePort"]) for d in c['Ports'] if d.has_key('PublicPort') ]
        ports_str = ",".join([str(p[0]) + "->" + str(p[1]) for p in ports])
        if len(ports_str) > width[6]:
            width[6] = len(ports_str)
    width[6] = max(width[6], len("EXPOSED PORTS"))

    print " %- *s   %- *s   %- *s   %- *s   %- *s   %- *s   %- *s" % (width[0], "NODE ID", 
                                                                      width[1], "STATUS", 
                                                                      width[2], "IMAGE VERSION", 
                                                                      width[3], "NAME", 
                                                                      width[4], "CONTAINER ID", 
                                                                      width[5], "CONTAINER NAME", 
                                                                      width[6], "EXPOSED PORTS")
    for c in containers:
        ports = [ (d["PublicPort"], d["PrivatePort"]) for d in c['Ports'] if d.has_key('PublicPort') ]
        ports_str = ",".join([str(p[0]) + "->" + str(p[1]) for p in ports])
        print " %- *s   %- *s   %- *s   %- *s   %- .*s   %- *s   %- *s" % (width[0], c['Labels']['NodeID'], 
                                                                           width[1], c['Status'], 
                                                                           width[2], c['Labels']['version'],
                                                                           width[3], c['Labels']['Name'],
                                                                           width[4], c['Id'], 
                                                                           width[5], c['Names'][0].lstrip("/"),
                                                                           width[6], ports_str) 
#}}}

#{{{ Create file devices
def create_file_devices(cmd):
    try:
        conf = exadt_conf.exadt_conf()
        root = conf.get_root(cmd.cluster)
    except exadt_conf.ConfError as e:
        print e
        sys.exit(1)
    try:
        exaconf = EXAConf.EXAConf(root, True)
    except EXAConf.EXAConfError as e:
        print e
        sys.exit(1) 
    try:
        byte_size = utils.units2bytes(cmd.size)
    except RuntimeError as e:
        print "ERROR:: %s" % e 
        sys.exit(1)
    # check if path does exist (do NOT create it)
    if cmd.path and not os.path.exists(cmd.path):
        print "ERROR:: Given path '%s' does not exist!" % cmd.path
        sys.exit(1)
    # ask user for confirmation if existing devices should be replaced
    if cmd.replace and not confirm("Do you really want to replace all file-devices of cluster '%s'?" % cmd.cluster):
        print "Aborted"
        sys.exit(0)
    try:
        devh = device_handler.device_handler(exaconf)
        devices = devh.create_file_devices(cmd.disk, cmd.num, byte_size, cmd.path, cmd.replace)
    except device_handler.DeviceError as e:
        print e
        sys.exit(1)
    if devices:
        if len(devices[1]) > 0:
            print "The following file devices have been removed:"
            for nid in devices[1].keys():
                print "Node %s : %s" % (nid, devices[1][nid])
        if len(devices[0]) > 0:
            print "Successfully created the following file devices:"
            for nid in devices[0].keys():
                print "Node %s : %s" % (nid, devices[0][nid])
#}}}

 #{{{ execute
def execute(cmd):
    try:
        conf = exadt_conf.exadt_conf()
        root = conf.get_root(cmd.cluster)
    except exadt_conf.ConfError as e:
        print e
        sys.exit(1)
    try:
        exaconf = EXAConf.EXAConf(root, True)
    except EXAConf.EXAConfError as e:
        print e
        sys.exit(1)
    try:
        dh = docker_handler.docker_handler()
        dh.set_exaconf(exaconf)
        dh.execute(cmd.command, all=cmd.all, quiet=cmd.quiet)
    except docker_handler.DockerError as e:
        print e
        sys.exit(1)
#}}}
 
#{{{ Stop database
def stop_database(cmd):
    try:
        conf = exadt_conf.exadt_conf()
        root = conf.get_root(cmd.cluster)
    except exadt_conf.ConfError as e:
        print e
        sys.exit(1)
    try:
        exaconf = EXAConf.EXAConf(root, True)
    except EXAConf.EXAConfError as e:
        print e
        sys.exit(1)
    try:
        drh = docker_rpc_handler.docker_rpc_handler(exaconf)
        if cmd.kill:
            drh.kill_database(cmd.name)
        else:
            drh.stop_database(cmd.name)
    except docker_handler.DockerError as e:
        print e
        sys.exit(1)
#}}}
  
#{{{ Start database
def start_database(cmd):
    try:
        conf = exadt_conf.exadt_conf()
        root = conf.get_root(cmd.cluster)
    except exadt_conf.ConfError as e:
        print e
        sys.exit(1)
    try:
        exaconf = EXAConf.EXAConf(root, True)
    except EXAConf.EXAConfError as e:
        print e
        sys.exit(1)
    try:
        drh = docker_rpc_handler.docker_rpc_handler(exaconf)
        drh.start_database(cmd.name)
    except docker_handler.DockerError as e:
        print e
        sys.exit(1)
#}}}
   
#{{{ List databases
def list_databases(cmd):
    try:
        conf = exadt_conf.exadt_conf()
        root = conf.get_root(cmd.cluster)
    except exadt_conf.ConfError as e:
        print e
        sys.exit(1)
    try:
        exaconf = EXAConf.EXAConf(root, True)
    except EXAConf.EXAConfError as e:
        print e
        sys.exit(1)
    try:
        drh = docker_rpc_handler.docker_rpc_handler(exaconf)
        drh.list_databases(short=cmd.short)
    except docker_handler.DockerError as e:
        print e
        sys.exit(1)
#}}}
 
#{{{ Print version
def print_version(cmd):
    print my_version
#}}}

#{{{ Collect info
def collect_info(cmd):
    """
    Creates an archive (tgz) with the following content:
        - 'exadt.info' : exadt version + MD5 sum of the executable
        - 'docker.info' : Docker version numbers
        - 'image.info' : output of 'docker inspect' for the associated Docker image
        - 'containers.info' : output of 'docker inspect' for all containers of the given cluster
        - '$node_id/etc/' : content of each containers 'etc' directory
        - '$node_id/logs/ : content of each containers 'logs' directory
    """

    err = False
    # determine cluster root
    # --> exit ONLY if cluster does not exist (continue on all other errors)
    try:
        conf = exadt_conf.exadt_conf()
        root = conf.get_root(cmd.cluster)
    except exadt_conf.ConfError as e:
        print e
        sys.exit(1)
    # determine exadt version and MD5 sum
    script = get_script_path()
    script_md5 = utils.md5(script)
    # get docker information
    try:
        dh = docker_handler.docker_handler(verbose=True)
        pp = pprint.PrettyPrinter()
        docker_info = pp.pformat(dh.version())
    except Exception as e:
        print e
        err = True
    # parse EXAConf
    try:
        exaconf = EXAConf.EXAConf(root, False)
    except EXAConf.EXAConfError as e:
        print e
        sys.exit(1)
    # EXAConf may be un-inititalized 
    image_info = None
    container_info = None
    initialized = False
    if not exaconf.initialized():
        print "Cluster '%s' has not been initialized." % cmd.cluster
    else:
        initialized = True
        dh.set_exaconf(exaconf)
        # collect image information
        try:
            image_info = pprint.pformat(dh.inspect_image(exaconf.get_docker_image()))
        except Exception as e:
            print e
            err = True
        # collect container information
        try:
            container_info = pprint.pformat(dh.inspect_containers())
        except Exception as e:
            print e
            err = True
        # save docker logs
        try:
            dh.save_logs()
        except Exception as e:
            print e
            err = True

    # create archive
    with tarfile.open(cmd.outfile, mode="w:gz") as tar:
        # exadt info
        exa_info = "Version: %s, MD5 : %s".encode("utf-8") % (my_version, script_md5)
        te = tarfile.TarInfo(os.path.join(info_arc_prefix, "exadt.info"))
        te.size = len(exa_info)
        te.mtime = time.time()
        tar.addfile(te, io.BytesIO(exa_info))
        # docker info
        td = tarfile.TarInfo(os.path.join(info_arc_prefix, "docker.info"))
        td.size = len(docker_info)
        td.mtime = time.time()
        tar.addfile(td, io.BytesIO(docker_info))
        # image info
        if image_info:
            ti = tarfile.TarInfo(os.path.join(info_arc_prefix, "image.info"))
            ti.size = len(image_info)
            ti.mtime = time.time()
            tar.addfile(ti, io.BytesIO(image_info))
        # container info
        if container_info:
            tc = tarfile.TarInfo(os.path.join(info_arc_prefix, "containers.info"))
            tc.size = len(container_info)
            tc.mtime = time.time()
            tar.addfile(tc, io.BytesIO(container_info))
        # add "/logs" and "/etc" directories
        if initialized:
            nodes_conf = exaconf.get_nodes_conf()
            for nid, conf in nodes_conf.iteritems():
                # logs
                try:
                    tar.add(os.path.join(conf.docker_volume, "logs"), 
                            arcname = os.path.join(info_arc_prefix, "n" + str(nid), "logs"))
                except Exception as e:
                    print e
                    err = True
                # etc
                # -> contains root-only-readable files, so we do it manually
                for base, dirs, files in os.walk(os.path.join(conf.docker_volume, "etc")):
                    for f in files:
                        try:
                            tar.add(os.path.join(base, f),
                                    arcname = os.path.join(info_arc_prefix,
                                                           "n"+str(nid), 
                                                           os.path.relpath(base, conf.docker_volume),
                                                           f)
                                   )
                        except IOError:
                            pass
                    for d in dirs:
                        try:
                            tar.add(os.path.join(base, d),
                                    arcname = os.path.join(info_arc_prefix, 
                                                           "n"+str(nid), 
                                                           os.path.relpath(base, conf.docker_volume),
                                                           d),
                                    recursive = False
                                   )
                        except IOError:
                            pass
        tar.close()
 
    print "All available information has been saved to '%s'.%s" % (cmd.outfile, "Some information could not be retrieved!" if err else "")
#}}}

# {{{ Main
def main():
    global confirm_yes
    
    parser = argparse.ArgumentParser(
            description = 'EXASOL Docker Tool',
            prog = 'exadt')
    parser.add_argument(
            '--yes', '-y',
            action='store_true',
            default=False,
            help='Do not ask for confirmations')
    cmdparser = parser.add_subparsers(
            title = 'commands',
            description = 'supported commands')

    # create cluster command
    parser_cc = cmdparser.add_parser(
            'create-cluster',
            help='Create a new cluster')
    parser_cc.add_argument(
            'cluster', type=str, metavar='NAME',
            help='Name for the new cluster')
    parser_cc.add_argument(
            '--root', '-r',
            required = True,
            help='Root directory for the new cluster')
    parser_cc.add_argument(
            '--create-root', '-c',
            action = 'store_true',
            help='Create root directory if it does not exist')
    parser_cc.set_defaults(func=create_cluster)
   
    # delete cluster command
    parser_dc = cmdparser.add_parser(
            'delete-cluster',
            help='Delete an existing cluster from the config (and clear data in its root directory)')
    parser_dc.add_argument(
            'cluster', type=str, metavar='CLUSTER',
            help='Name of the cluster')
    parser_dc.add_argument(
            '--keep-root', '-k',
            action = 'store_true',
            help='Keep root directory and contents (default: delete it)')
    parser_dc.add_argument(
            '--keep-mapped-devices', '-d',
            action = 'store_true',
            help='Keep mapped devices, i. e. file-devices outside of the root directory (default: delete them)')
    parser_dc.set_defaults(func=delete_cluster)
 
    # init cluster command
    parser_ic = cmdparser.add_parser(
            'init-cluster',
            help='Initialize the configuration and directory structure of a cluster')
    parser_ic.add_argument(
            'cluster', type=str, metavar='CLUSTER',
            help='Name of the cluster')
    parser_ic.add_argument(
            '--image', '-i',
            required = True,
            help='Docker image to use')
    parser_ic.add_argument(
            '--num-nodes', '-m',
            type = int,
            default = 1,
            help = 'Nr. of nodes (i. e. containers, default: 1)')
    parser_ic.add_argument(
            '--license', '-l',
            required = True,
            help = 'Path to the license file')
    parser_ic.add_argument(
            '--device-type', '-d',
            type = str,
            default = 'file',
            help = 'Type of EXAStorage device (block | file)')
    parser_ic.add_argument(
            '--auto-storage', '-a',
            action = 'store_true',
            help = "Automatically create file-devices, disks and volumes (requires sufficient free space in the root directory and only works for device-type 'file')")
    parser_ic.add_argument(
            '--db-version', '-D',
            type = str,
            help='Database version number (necessary if image contains multiple database installations)')
    parser_ic.add_argument(
            '--os-version', '-O',
            type = str,
            help='EXAClusterOS version number')
    parser_ic.add_argument(
            '--img-version', '-I',
            type = str,
            help='Image version number')
    parser_ic.add_argument(
            '--force', '-f',
            action = 'store_true',
            help='Force re-initialization of the root directory (if not empty)')
    parser_ic.set_defaults(func=init_cluster)
  
    # init-sc command
    parser_isc = cmdparser.add_parser(
            'init-sc',
            help='Initialize the container of a self-contained image') 
    parser_isc.add_argument(
            '--template', '-t',
            default = False,
            action = 'store_true',
            help="Print an EXAConf template and exit (also prepares '/exa')")
    parser_isc.add_argument(
            '--node-id', '-i',
            type = str,
            default = '11',
            help='Node ID of the current container')
    parser_isc.add_argument(
            '--num-nodes', '-n',
            type = int,
            default = 1,
            help='Number of cluster nodes')
    parser_isc.add_argument(
            '--img-version', '-I',
            type = str,
            help='Version number of the new Docker image')
    parser_isc.add_argument(
            '--db-version', '-D',
            type = str,
            help='DB version number')
    parser_isc.add_argument(
            '--os-version', '-O',
            type = str,
            help='OS version number')
    parser_isc.set_defaults(func=init_sc)

    # list clusters command
    parser_lc = cmdparser.add_parser(
            'list-clusters',
            help='List all existing clusters and their root directory')
    parser_lc.set_defaults(func=list_clusters)
    
    # update cluster command
    parser_upc = cmdparser.add_parser(
            'update-cluster',
            help='Update given cluster (by changing the docker image)')
    parser_upc.add_argument(
            'cluster', type=str, metavar="CLUSTER",
            help='Name of the cluster to be updated')
    parser_upc.add_argument(
            '--image', '-i',
            required=True,
            help='Name of the new Docker image')
    parser_upc.add_argument(
            '--db-version', '-D',
            type = str,
            help='DB version number')
    parser_upc.add_argument(
            '--os-version', '-O',
            type = str,
            help='OS version number')
    parser_upc.add_argument(
            '--img-version', '-I',
            type = str,
            help='Version number of the new Docker image')
    parser_upc.set_defaults(func=update_cluster)
     
    # update-sc command
    parser_usc = cmdparser.add_parser(
            'update-sc',
            help='Update the container of a self-contained image')
    parser_usc.add_argument(
            '--img-version', '-I',
            type = str,
            help='Version number of the new Docker image')
    parser_usc.add_argument(
            '--db-version', '-D',
            type = str,
            help='DB version number')
    parser_usc.add_argument(
            '--os-version', '-O',
            type = str,
            help='OS version number')
    parser_usc.set_defaults(func=update_sc)
 
    # start cluster command
    parser_sc = cmdparser.add_parser(
            'start-cluster',
            help='Start given cluster')
    parser_sc.add_argument(
            'cluster', type=str, metavar='CLUSTER',
            help='Name of the cluster to be started')
    parser_sc.add_argument(
            '--command', '-c',
            help="Custom start command for all containers (set as 'entrypoint')")
    parser_sc.add_argument(
            '--verbose', '-V',
            action = 'store_true',
            help='Increase output')
    parser_sc.set_defaults(func=start_cluster)
  
    # stop cluster command
    parser_stc = cmdparser.add_parser(
            'stop-cluster',
            help='Stop given cluster')
    parser_stc.add_argument(
            'cluster', type=str, metavar="CLUSTER",
            help='Name of the cluster to be stopped')
    parser_stc.add_argument(
            '--timeout', '-t',
            default=60,
            help='Seconds to wait for a container to stop before sending SIGKILL (default: 60s)')
    parser_stc.add_argument(
            '--verbose', '-V',
            action = 'store_true',
            help='Increase output')
    parser_stc.set_defaults(func=stop_cluster)
   
    # ps command
    parser_psc = cmdparser.add_parser(
            'ps',
            help='List all containers of the given cluster')
    parser_psc.add_argument(
            'cluster', type=str, metavar="CLUSTER",
            help='Name of the cluster')
    parser_psc.add_argument(
            '--verbose', '-V',
            action = 'store_true',
            help='Dump all container info from docker')
    parser_psc.set_defaults(func=ps)
     
    # create file devices command
    parser_cfdc = cmdparser.add_parser(
            'create-file-devices',
            help='Create files as storage devices for all nodes of the given cluster')
    parser_cfdc.add_argument(
            'cluster', type=str, metavar="CLUSTER",
            help='Name of the cluster')
    parser_cfdc.add_argument(
            '--num', '-n',
            type = int,
            default = 1,
            help='Nr. of devices (per node) to be created')
    parser_cfdc.add_argument(
            '--size', '-s',
            required = True,
            type = str,
            help='Size of a device file')
    parser_cfdc.add_argument(
            '--disk', '-d',
            type = str,
            default = "default",
            help="Storage disk to which the device should be added (default: 'default')")
    parser_cfdc.add_argument(
            '--path', '-p',
            type=str,
            help='Create device-files in given directory instead of default directory')
    parser_cfdc.add_argument(
            '--replace', '-r',
            action='store_true',
            help='Replace existing file-devices instead of adding them')
    parser_cfdc.set_defaults(func=create_file_devices)
 
    # docker version command
    parser_dv = cmdparser.add_parser(
            'docker-version',
            help='Print docker version information')
    parser_dv.set_defaults(func=docker_version)
    
    # exec command
    parser_ex = cmdparser.add_parser(
            'exec',
            help='Execute the given command on a running container of the given cluster')
    parser_ex.add_argument(
            'cluster', type=str, metavar="CLUSTER",
            help='Name of the cluster')
    parser_ex.add_argument(
            '--command', '-c',
            help='Command to be executed')
    parser_ex.add_argument(
            '--all', '-a',
            action='store_true',
            help='Execute the given command on all running containers')
    parser_ex.add_argument(
            '--quiet', '-q',
            action='store_true',
            default=False,
            help='Suppress all output, except from the given command')
    parser_ex.set_defaults(func=execute)
     
    # start-db command
    parser_sadb = cmdparser.add_parser(
            'start-db',
            help='Start all databases (or the given one) in the given cluster')
    parser_sadb.add_argument(
            'cluster', type=str, metavar="CLUSTER",
            help='Name of the cluster')
    parser_sadb.add_argument(
            '--name', '-n',
            type=str,
            default="all",
            help='Database to be started')
    parser_sadb.set_defaults(func=start_database)
      
    # stop-db command
    parser_stdb = cmdparser.add_parser(
            'stop-db',
            help='Stop all databases (or the given one) in the given cluster')
    parser_stdb.add_argument(
            'cluster', type=str, metavar="CLUSTER",
            help='Name of the cluster')
    parser_stdb.add_argument(
            '--name', '-n',
            type=str,
            default="all",
            help='Database to be stopped')
    parser_stdb.add_argument(
            '--kill', '-k',
            action='store_true',
            default=False,
            help='Force-stop DB immediately')
    parser_stdb.set_defaults(func=stop_database)
       
    # list-dbs command
    parser_lsdb = cmdparser.add_parser(
            'list-dbs',
            help='List all databases in the given cluster')
    parser_lsdb.add_argument(
            'cluster', type=str, metavar="CLUSTER",
            help='Name of the cluster')
    parser_lsdb.add_argument(
            '--short', '-s',
            action='store_true',
            default=False,
            help='Short listing (only names)')
    parser_lsdb.set_defaults(func=list_databases)
       
    # version command
    parser_ver = cmdparser.add_parser(
            'version',
            help='Print exadt version number')
    parser_ver.set_defaults(func=print_version)
        
    # collect-info command
    parser_cl = cmdparser.add_parser(
            'collect-info',
            help='Collect log output and debugging information')
    parser_cl.add_argument(
            'cluster', type=str, metavar="CLUSTER",
            help='Name of the cluster')
    parser_cl.add_argument(
            '--outfile', '-o',
            type=str,
            default="./exasol_info.tgz",
            help='Name of the output file')
    parser_cl.set_defaults(func=collect_info)

    command = parser.parse_args()
    if command.yes: confirm_yes = True
    command.func(command)

if __name__ == '__main__':
    main()
# }}}

